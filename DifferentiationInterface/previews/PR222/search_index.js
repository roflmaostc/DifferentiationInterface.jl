var documenterSearchIndex = {"docs":
[{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Main","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We present a typical workflow with DifferentiationInterface.jl and showcase its potential performance benefits.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentiationInterface\n\nimport ForwardDiff, Enzyme  # ⚠️ import the backends you want to use ⚠️","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tip: Tip\nImporting backends with import instead of using avoids name conflicts and makes sure you are using operators from DifferentiationInterface.jl. This is useful since most backends also export operators like gradient and jacobian.","category":"page"},{"location":"tutorial/#Computing-a-gradient","page":"Tutorial","title":"Computing a gradient","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A common use case of automatic differentiation (AD) is optimizing real-valued functions with first- or second-order methods. Let's define a simple objective and a random input vector","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x) = sum(abs2, x)\n\nx = [1.0, 2.0, 3.0]\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To compute its gradient, we need to choose a \"backend\", i.e. an AD package that DifferentiationInterface.jl will call under the hood. Most backend types are defined by ADTypes.jl and re-exported by DifferentiationInterface.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ForwardDiff.jl is very generic and efficient for low-dimensional inputs, so it's a good starting point:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backend = AutoForwardDiff()\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now you can use DifferentiationInterface.jl to get the gradient:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gradient(f, backend, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Was that fast? BenchmarkTools.jl helps you answer that question.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BenchmarkTools\n@btime gradient($f, $backend, $x);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"More or less what you would get if you just used the API from ForwardDiff.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime ForwardDiff.gradient($f, $x);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Not bad, but you can do better.","category":"page"},{"location":"tutorial/#Overwriting-a-gradient","page":"Tutorial","title":"Overwriting a gradient","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since you know how much space your gradient will occupy (the same as your input x), you can pre-allocate that memory and offer it to AD. Some backends get a speed boost from this trick.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grad = similar(x)\ngradient!(f, grad, backend, x)\n\ngrad  # has been mutated","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bang indicates that one of the arguments of gradient! might be mutated. More precisely, our convention is that every positional argument between the function and the backend is mutated (and the extras too, see below).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient!($f, _grad, $backend, $x) evals=1 setup=(_grad=similar($x));","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For some reason the in-place version is not much better than your first attempt. However, it has one less allocation, which corresponds to the gradient vector you provided. Don't worry, you can get even more performance.","category":"page"},{"location":"tutorial/#Preparing-for-multiple-gradients","page":"Tutorial","title":"Preparing for multiple gradients","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Internally, ForwardDiff.jl creates some data structures to keep track of things. These objects can be reused between gradient computations, even on different input values. We abstract away the preparation step behind a backend-agnostic syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"extras = prepare_gradient(f, backend, x)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You don't need to know what this object is, you just need to pass it to the gradient operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grad = similar(x)\ngradient!(f, grad, backend, x, extras)\n\ngrad  # has been mutated","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Preparation makes the gradient computation much faster, and (in this case) allocation-free.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient!($f, _grad, $backend, $x, _extras) evals=1 setup=(\n    _grad=similar($x);\n    _extras=prepare_gradient($f, $backend, $x)\n);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Beware that the extras object is nearly always mutated by differentiation operators, even though it is given as the last positional argument.","category":"page"},{"location":"tutorial/#Switching-backends","page":"Tutorial","title":"Switching backends","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The whole point of DifferentiationInterface.jl is that you can easily experiment with different AD solutions. Typically, for gradients, reverse mode AD might be a better fit. So let's try the state-of-the-art Enzyme.jl!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For this one, the backend definition is slightly more involved, because you need to feed the \"mode\" to the object from ADTypes.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backend2 = AutoEnzyme(; mode=Enzyme.Reverse)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But once it is done, things run smoothly with exactly the same syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gradient(f, backend2, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And you can run the same benchmarks:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@btime gradient!($f, _grad, $backend2, $x, _extras) evals=1 setup=(\n    _grad=similar($x);\n    _extras=prepare_gradient($f, $backend2, $x)\n);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Not only is it blazingly fast, you achieved this speedup without looking at the docs of either ForwardDiff.jl or Enzyme.jl! In short, DifferentiationInterface.jl allows for easy testing and comparison of AD backends. If you want to go further, check out the DifferentiationInterfaceTest.jl tutorial. It provides benchmarking utilities to compare backends and help you select the one that is best suited for your problem.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"DifferentiationInterface","category":"page"},{"location":"api/#DifferentiationInterface","page":"API reference","title":"DifferentiationInterface","text":"DifferentiationInterface\n\nAn interface to various automatic differentiation backends in Julia.\n\nExports\n\nAutoChainRules\nAutoDiffractor\nAutoEnzyme\nAutoFastDifferentiation\nAutoFiniteDiff\nAutoFiniteDifferences\nAutoForwardDiff\nAutoPolyesterForwardDiff\nAutoReverseDiff\nAutoSparse\nAutoSymbolics\nAutoTapir\nAutoTracker\nAutoZygote\nDifferentiateWith\nSecondOrder\ncheck_available\ncheck_hessian\ncheck_twoarg\nderivative\nderivative!\ngradient\ngradient!\nhessian\nhessian!\nhvp\nhvp!\njacobian\njacobian!\nprepare_derivative\nprepare_gradient\nprepare_hessian\nprepare_hvp\nprepare_jacobian\nprepare_pullback\nprepare_pushforward\nprepare_second_derivative\npullback\npullback!\npushforward\npushforward!\nsecond_derivative\nsecond_derivative!\nvalue_and_derivative\nvalue_and_derivative!\nvalue_and_gradient\nvalue_and_gradient!\nvalue_and_jacobian\nvalue_and_jacobian!\nvalue_and_pullback\nvalue_and_pullback!\nvalue_and_pullback!_split\nvalue_and_pullback_split\nvalue_and_pushforward\nvalue_and_pushforward!\n\n\n\n\n\n","category":"module"},{"location":"api/#Derivative","page":"API reference","title":"Derivative","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_derivative\nderivative\nderivative!\nvalue_and_derivative\nvalue_and_derivative!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_derivative","page":"API reference","title":"DifferentiationInterface.prepare_derivative","text":"prepare_derivative(f,     backend, x) -> extras\nprepare_derivative(f!, y, backend, x) -> extras\n\nCreate an extras object subtyping DerivativeExtras that can be given to derivative operators.\n\nBeware that in the two-argument case, y is mutated by f! during preparation.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.derivative","page":"API reference","title":"DifferentiationInterface.derivative","text":"derivative(f,     backend, x, [extras]) -> der\nderivative(f!, y, backend, x, [extras]) -> der\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.derivative!","page":"API reference","title":"DifferentiationInterface.derivative!","text":"derivative!(f,     der, backend, x, [extras]) -> der\nderivative!(f!, y, der, backend, x, [extras]) -> der\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_derivative","page":"API reference","title":"DifferentiationInterface.value_and_derivative","text":"value_and_derivative(f,     backend, x, [extras]) -> (y, der)\nvalue_and_derivative(f!, y, backend, x, [extras]) -> (y, der)\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_derivative!","page":"API reference","title":"DifferentiationInterface.value_and_derivative!","text":"value_and_derivative!(f,     der, backend, x, [extras]) -> (y, der)\nvalue_and_derivative!(f!, y, der, backend, x, [extras]) -> (y, der)\n\n\n\n\n\n","category":"function"},{"location":"api/#Gradient","page":"API reference","title":"Gradient","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_gradient\ngradient\ngradient!\nvalue_and_gradient\nvalue_and_gradient!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_gradient","page":"API reference","title":"DifferentiationInterface.prepare_gradient","text":"prepare_gradient(f, backend, x) -> extras\n\nCreate an extras object subtyping GradientExtras that can be given to gradient operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.gradient","page":"API reference","title":"DifferentiationInterface.gradient","text":"gradient(f, backend, x, [extras]) -> grad\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.gradient!","page":"API reference","title":"DifferentiationInterface.gradient!","text":"gradient!(f, grad, backend, x, [extras]) -> grad\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_gradient","page":"API reference","title":"DifferentiationInterface.value_and_gradient","text":"value_and_gradient(f, backend, x, [extras]) -> (y, grad)\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_gradient!","page":"API reference","title":"DifferentiationInterface.value_and_gradient!","text":"value_and_gradient!(f, grad, backend, x, [extras]) -> (y, grad)\n\n\n\n\n\n","category":"function"},{"location":"api/#Jacobian","page":"API reference","title":"Jacobian","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_jacobian\njacobian\njacobian!\nvalue_and_jacobian\nvalue_and_jacobian!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_jacobian","page":"API reference","title":"DifferentiationInterface.prepare_jacobian","text":"prepare_jacobian(f,     backend, x) -> extras\nprepare_jacobian(f!, y, backend, x) -> extras\n\nCreate an extras object subtyping JacobianExtras that can be given to Jacobian operators.\n\nBeware that in the two-argument case, y is mutated by f! during preparation.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.jacobian","page":"API reference","title":"DifferentiationInterface.jacobian","text":"jacobian(f,     backend, x, [extras]) -> jac\njacobian(f!, y, backend, x, [extras]) -> jac\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.jacobian!","page":"API reference","title":"DifferentiationInterface.jacobian!","text":"jacobian!(f,     jac, backend, x, [extras]) -> jac\njacobian!(f!, y, jac, backend, x, [extras]) -> jac\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_jacobian","page":"API reference","title":"DifferentiationInterface.value_and_jacobian","text":"value_and_jacobian(f,     backend, x, [extras]) -> (y, jac)\nvalue_and_jacobian(f!, y, backend, x, [extras]) -> (y, jac)\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_jacobian!","page":"API reference","title":"DifferentiationInterface.value_and_jacobian!","text":"value_and_jacobian!(f,     jac, backend, x, [extras]) -> (y, jac)\nvalue_and_jacobian!(f!, y, jac, backend, x, [extras]) -> (y, jac)\n\n\n\n\n\n","category":"function"},{"location":"api/#Second-order","page":"API reference","title":"Second order","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"SecondOrder","category":"page"},{"location":"api/#DifferentiationInterface.SecondOrder","page":"API reference","title":"DifferentiationInterface.SecondOrder","text":"SecondOrder\n\nCombination of two backends for second-order differentiation.\n\nConstructor\n\nSecondOrder(outer, inner)\n\nFields\n\nouter::ADTypes.AbstractADType: backend for the outer differentiation\ninner::ADTypes.AbstractADType: backend for the inner differentiation\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_second_derivative\nsecond_derivative\nsecond_derivative!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_second_derivative","page":"API reference","title":"DifferentiationInterface.prepare_second_derivative","text":"prepare_second_derivative(f, backend, x) -> extras\n\nCreate an extras object subtyping SecondDerivativeExtras that can be given to second derivative operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.second_derivative","page":"API reference","title":"DifferentiationInterface.second_derivative","text":"second_derivative(f, backend, x, [extras]) -> der2\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.second_derivative!","page":"API reference","title":"DifferentiationInterface.second_derivative!","text":"second_derivative!(f, der2, backend, x, [extras]) -> der2\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_hvp\nhvp\nhvp!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_hvp","page":"API reference","title":"DifferentiationInterface.prepare_hvp","text":"prepare_hvp(f, backend, x, v) -> extras\n\nCreate an extras object subtyping HVPExtras that can be given to Hessian-vector product operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.hvp","page":"API reference","title":"DifferentiationInterface.hvp","text":"hvp(f, backend, x, v, [extras]) -> p\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.hvp!","page":"API reference","title":"DifferentiationInterface.hvp!","text":"hvp!(f, p, backend, x, v, [extras]) -> p\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_hessian\nhessian\nhessian!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_hessian","page":"API reference","title":"DifferentiationInterface.prepare_hessian","text":"prepare_hessian(f, backend, x) -> extras\n\nCreate an extras object subtyping HessianExtras that can be given to Hessian operators.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.hessian","page":"API reference","title":"DifferentiationInterface.hessian","text":"hessian(f, backend, x, [extras]) -> hess\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.hessian!","page":"API reference","title":"DifferentiationInterface.hessian!","text":"hessian!(f, hess, backend, x, [extras]) -> hess\n\n\n\n\n\n","category":"function"},{"location":"api/#Primitives","page":"API reference","title":"Primitives","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_pushforward\npushforward\npushforward!\nvalue_and_pushforward\nvalue_and_pushforward!","category":"page"},{"location":"api/#DifferentiationInterface.prepare_pushforward","page":"API reference","title":"DifferentiationInterface.prepare_pushforward","text":"prepare_pushforward(f,     backend, x, dx) -> extras\nprepare_pushforward(f!, y, backend, x, dx) -> extras\n\nCreate an extras object subtyping PushforwardExtras that can be given to pushforward operators.\n\nBeware that in the two-argument case, y is mutated by f! during preparation.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.pushforward","page":"API reference","title":"DifferentiationInterface.pushforward","text":"pushforward(f,     backend, x, dx, [extras]) -> dy\npushforward(f!, y, backend, x, dx, [extras]) -> dy\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.pushforward!","page":"API reference","title":"DifferentiationInterface.pushforward!","text":"pushforward!(f,     dy, backend, x, dx, [extras]) -> dy\npushforward!(f!, y, dy, backend, x, dx, [extras]) -> dy\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_pushforward","page":"API reference","title":"DifferentiationInterface.value_and_pushforward","text":"value_and_pushforward(f,     backend, x, dx, [extras]) -> (y, dy)\nvalue_and_pushforward(f!, y, backend, x, dx, [extras]) -> (y, dy)\n\ninfo: Info\nRequired primitive for forward mode backends.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_pushforward!","page":"API reference","title":"DifferentiationInterface.value_and_pushforward!","text":"value_and_pushforward!(f,     dy, backend, x, dx, [extras]) -> (y, dy)\nvalue_and_pushforward!(f!, y, dy, backend, x, dx, [extras]) -> (y, dy)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API reference","title":"API reference","text":"prepare_pullback\npullback\npullback!\nvalue_and_pullback\nvalue_and_pullback!\nvalue_and_pullback_split\nvalue_and_pullback!_split","category":"page"},{"location":"api/#DifferentiationInterface.prepare_pullback","page":"API reference","title":"DifferentiationInterface.prepare_pullback","text":"prepare_pullback(f,     backend, x, dy) -> extras\nprepare_pullback(f!, y, backend, x, dy) -> extras\n\nCreate an extras object subtyping PullbackExtras that can be given to pullback operators.\n\nBeware that in the two-argument case, y is mutated by f! during preparation.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.pullback","page":"API reference","title":"DifferentiationInterface.pullback","text":"pullback(f,     backend, x, dy, [extras]) -> dx\npullback(f!, y, backend, x, dy, [extras]) -> dx\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.pullback!","page":"API reference","title":"DifferentiationInterface.pullback!","text":"pullback!(f,     dx, backend, x, dy, [extras]) -> dx\npullback!(f!, y, dx, backend, x, dy, [extras]) -> dx\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_pullback","page":"API reference","title":"DifferentiationInterface.value_and_pullback","text":"value_and_pullback(f,     backend, x, dy, [extras]) -> (y, dx)\nvalue_and_pullback(f!, y, backend, x, dy, [extras]) -> (y, dx)\n\ninfo: Info\nRequired primitive for reverse mode backends.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_pullback!","page":"API reference","title":"DifferentiationInterface.value_and_pullback!","text":"value_and_pullback!(f,     dx, backend, x, dy, [extras]) -> (y, dx)\nvalue_and_pullback!(f!, y, dx, backend, x, dy, [extras]) -> (y, dx)\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_pullback_split","page":"API reference","title":"DifferentiationInterface.value_and_pullback_split","text":"value_and_pullback_split(f,     backend, x, [extras]) -> (y, pbf(   dy) -> dx)\nvalue_and_pullback_split(f!, y, backend, x, [extras]) -> (y, pbf(y, dy) -> dx)\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.value_and_pullback!_split","page":"API reference","title":"DifferentiationInterface.value_and_pullback!_split","text":"value_and_pullback!_split(f,     backend, x, [extras]) -> (y, pbf!(   dx, dy) -> dx)\nvalue_and_pullback!_split(f!, y, backend, x, [extras]) -> (y, pbf!(y, dx, dy) -> dx)\n\n\n\n\n\n","category":"function"},{"location":"api/#Backend-queries","page":"API reference","title":"Backend queries","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"check_available\ncheck_twoarg\ncheck_hessian","category":"page"},{"location":"api/#DifferentiationInterface.check_available","page":"API reference","title":"DifferentiationInterface.check_available","text":"check_available(backend)\n\nCheck whether backend is available (i.e. whether the extension is loaded).\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.check_twoarg","page":"API reference","title":"DifferentiationInterface.check_twoarg","text":"check_twoarg(backend)\n\nCheck whether backend supports differentiation of two-argument functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterface.check_hessian","page":"API reference","title":"DifferentiationInterface.check_hessian","text":"check_hessian(backend)\n\nCheck whether backend supports second order differentiation by trying to compute a hessian.\n\nwarning: Warning\nMight take a while due to compilation time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Translation","page":"API reference","title":"Translation","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"DifferentiateWith","category":"page"},{"location":"api/#DifferentiationInterface.DifferentiateWith","page":"API reference","title":"DifferentiationInterface.DifferentiateWith","text":"DifferentiateWith\n\nCallable function wrapper that enforces differentiation with a specified (inner) backend.\n\nThis works by defining new rules overriding the behavior of the outer backend that would normally be used.\n\nwarning: Warning\nThis is an experimental functionality, whose API cannot yet be considered stable. At the moment, it only supports one-argument functions, and rules are only defined for ChainRules.jl-compatible outer backends.\n\nFields\n\nf: the function in question\nbackend::AbstractADType: the inner backend to use for differentiation\n\nConstructor\n\nDifferentiateWith(f, backend)\n\nExample\n\nusing DifferentiationInterface\nimport ForwardDiff, Zygote\n\nfunction f(x)\n    a = Vector{eltype(x)}(undef, 1)\n    a[1] = sum(x)  # mutation that breaks Zygote\n    return a[1]\nend\n\ndw = DifferentiateWith(f, AutoForwardDiff());\n\ngradient(dw, AutoZygote(), [2.0])  # calls ForwardDiff instead\n\n# output\n\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This is not part of the public API.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterface]\nPublic = false","category":"page"},{"location":"api/#DifferentiationInterface.AdjacencyGraph","page":"API reference","title":"DifferentiationInterface.AdjacencyGraph","text":"AdjacencyGraph\n\nRepresent a graph between the columns of a symmetric n × n matrix A with nonzero diagonal elements.\n\nThis graph is defined as G = (C, E) where C = 1:n is the set of columns and (i, j) ∈ E whenever A[i, j] is nonzero for some j ∈ 1:m, j ≠ i.\n\nFields\n\nA_colmajor::AbstractMatrix: output of col_major applied to A\n\nReference\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.BipartiteGraph","page":"API reference","title":"DifferentiationInterface.BipartiteGraph","text":"BipartiteGraph\n\nRepresent a bipartite graph between the rows and the columns of a non-symmetric m × n matrix A.\n\nThis graph is defined as G = (R, C, E) where R = 1:m is the set of row indices, C = 1:n is the set of column indices and (i, j) ∈ E whenever A[i, j] is nonzero.\n\nFields\n\nA_colmajor::AbstractMatrix: output of col_major applied to A\nA_rowmajor::AbstractMatrix: output of row_major applied to A\n\nReference\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.CompressedMatrix","page":"API reference","title":"DifferentiationInterface.CompressedMatrix","text":"CompressedMatrix{dir}\n\nCompressed representation B of a sparse matrix A ∈ ℝ^{m×n} obtained by summing some of its columns (if dir == :col) or rows (if dir == :row), grouped by color.\n\nFields\n\nsparsity::AbstractMatrix{Bool}: boolean sparsity pattern of the matrix A\ncolors::Vector{Int}: vector such that\nif dir ==:col, thencolors[j] ∈ 1:cis the color of columnj`\nif dir ==:row, thencolors[i] ∈ 1:cis the color of rowi`\ngroups::Vector{Vector{Int}}: vector of length c such that\nif dir == :col, then groups[k] is the vector of column indices assigned to the same color k ∈ 1:c\nif dir == :row, then groups[k] is the vector of row indices assigned to the same color k ∈ 1:c\naggregates::AbstractMatrix: matrix B such that\nif dir == :col, then size(B) = (m, c) and B[:, c] = sum(A[:, k] for k in groups[c])\nif dir == :row, then size(B) = (c, n) and B[c, :] = sum(A[k, :] for k in groups[c])\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.CompressedMatrix-Union{Tuple{dir}, NTuple{4, Any}} where dir","page":"API reference","title":"DifferentiationInterface.CompressedMatrix","text":"CompressedMatrix{dir}(sparsity, groups, aggregates)\n\nConstructor for CompressedMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.DerivativeExtras","page":"API reference","title":"DifferentiationInterface.DerivativeExtras","text":"DerivativeExtras\n\nAbstract type for additional information needed by derivative operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ForwardOverForward","page":"API reference","title":"DifferentiationInterface.ForwardOverForward","text":"ForwardOverForward\n\nTraits identifying second-order backends that compute HVPs in forward over forward mode (inefficient).\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ForwardOverReverse","page":"API reference","title":"DifferentiationInterface.ForwardOverReverse","text":"ForwardOverReverse\n\nTraits identifying second-order backends that compute HVPs in forward over reverse mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.GradientExtras","page":"API reference","title":"DifferentiationInterface.GradientExtras","text":"GradientExtras\n\nAbstract type for additional information needed by gradient operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.GreedyColoringAlgorithm","page":"API reference","title":"DifferentiationInterface.GreedyColoringAlgorithm","text":"GreedyColoringAlgorithm <: ADTypes.AbstractColoringAlgorithm\n\nMatrix coloring algorithm for sparse Jacobians and Hessians.\n\nCompatible with the ADTypes.jl coloring framework.\n\nSee also\n\nADTypes.column_coloring\nADTypes.row_coloring\nADTypes.symmetric_coloring\n\nReference\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.HVPExtras","page":"API reference","title":"DifferentiationInterface.HVPExtras","text":"HVPExtras\n\nAbstract type for additional information needed by Hessian-vector product operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.HessianExtras","page":"API reference","title":"DifferentiationInterface.HessianExtras","text":"HessianExtras\n\nAbstract type for additional information needed by Hessian operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.JacobianExtras","page":"API reference","title":"DifferentiationInterface.JacobianExtras","text":"JacobianExtras\n\nAbstract type for additional information needed by Jacobian operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.MutationNotSupported","page":"API reference","title":"DifferentiationInterface.MutationNotSupported","text":"MutationNotSupported\n\nTrait identifying backends that do not support two-argument functions f!(y, x).\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.MutationSupported","page":"API reference","title":"DifferentiationInterface.MutationSupported","text":"MutationSupported\n\nTrait identifying backends that support two-argument functions f!(y, x).\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.PullbackExtras","page":"API reference","title":"DifferentiationInterface.PullbackExtras","text":"PullbackExtras\n\nAbstract type for additional information needed by pullback operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.PullbackFast","page":"API reference","title":"DifferentiationInterface.PullbackFast","text":"PullbackFast\n\nTrait identifying backends that support efficient pullbacks.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.PullbackSlow","page":"API reference","title":"DifferentiationInterface.PullbackSlow","text":"PullbackSlow\n\nTrait identifying backends that do not support efficient pullbacks.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.PushforwardExtras","page":"API reference","title":"DifferentiationInterface.PushforwardExtras","text":"PushforwardExtras\n\nAbstract type for additional information needed by pushforward operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.PushforwardFast","page":"API reference","title":"DifferentiationInterface.PushforwardFast","text":"PushforwardFast\n\nTrait identifying backends that support efficient pushforwards.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.PushforwardSlow","page":"API reference","title":"DifferentiationInterface.PushforwardSlow","text":"PushforwardSlow\n\nTrait identifying backends that do not support efficient pushforwards.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ReverseOverForward","page":"API reference","title":"DifferentiationInterface.ReverseOverForward","text":"ReverseOverForward\n\nTraits identifying second-order backends that compute HVPs in reverse over forward mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.ReverseOverReverse","page":"API reference","title":"DifferentiationInterface.ReverseOverReverse","text":"ReverseOverReverse\n\nTraits identifying second-order backends that compute HVPs in reverse over reverse mode.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.SecondDerivativeExtras","page":"API reference","title":"DifferentiationInterface.SecondDerivativeExtras","text":"SecondDerivativeExtras\n\nAbstract type for additional information needed by second derivative operators.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterface.SymbolicsSparsityDetector","page":"API reference","title":"DifferentiationInterface.SymbolicsSparsityDetector","text":"SymbolicsSparsityDetector <: ADTypes.AbstractSparsityDetector\n\nSparsity detection algorithm based on the Symbolics.jl tracing system.\n\nCompatible with the ADTypes.jl sparsity detection framework.\n\ndanger: Danger\nThis functionality is implemented in an extension, and requires Symbolics.jl to be loaded.\n\nSee also\n\nADTypes.jacobian_sparsity\nADTypes.hessian_sparsity\n\nReference\n\nSparsity Programming: Automated Sparsity-Aware Optimizations in Differentiable Programming, Gowda et al. (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/#ADTypes.mode-Tuple{SecondOrder}","page":"API reference","title":"ADTypes.mode","text":"mode(backend::SecondOrder)\n\nReturn the outer mode of the second-order backend.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.basis-Tuple{ADTypes.AbstractADType, AbstractArray, Any}","page":"API reference","title":"DifferentiationInterface.basis","text":"basis(backend, a::AbstractArray, i::CartesianIndex)\n\nConstruct the i-th stardard basis array in the vector space of a with element type eltype(a).\n\nNote\n\nIf an AD backend benefits from a more specialized basis array implementation, this function can be extended on the backend type.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.col_major-Tuple{M} where M<:(AbstractMatrix)","page":"API reference","title":"DifferentiationInterface.col_major","text":"col_major(A::AbstractMatrix)\n\nConstruct a column-major representation of the matrix A.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.mutation_support-Tuple{ADTypes.AbstractADType}","page":"API reference","title":"DifferentiationInterface.mutation_support","text":"mutation_support(backend)\n\nReturn MutationSupported or MutationNotSupported in a statically predictable way.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.pick_chunksize-Tuple{Integer}","page":"API reference","title":"DifferentiationInterface.pick_chunksize","text":"pick_chunksize(input_length)\n\nPick a reasonable chunk size for chunked derivative evaluation with an input of length input_length.\n\nThe result cannot be larger than DEFAULT_CHUNKSIZE=8.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.pullback_performance-Tuple{ADTypes.AbstractADType}","page":"API reference","title":"DifferentiationInterface.pullback_performance","text":"pullback_performance(backend)\n\nReturn PullbackFast or PullbackSlow in a statically predictable way.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.pushforward_performance-Tuple{ADTypes.AbstractADType}","page":"API reference","title":"DifferentiationInterface.pushforward_performance","text":"pushforward_performance(backend)\n\nReturn PushforwardFast or PushforwardSlow in a statically predictable way.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterface.row_major-Tuple{M} where M<:(AbstractMatrix)","page":"API reference","title":"DifferentiationInterface.row_major","text":"row_major(A::AbstractMatrix)\n\nConstruct a row-major representation of the matrix A.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"design/#Package-design","page":"Package design","title":"Package design","text":"","category":"section"},{"location":"design/#ssec-requirements","page":"Package design","title":"Backend requirements","text":"","category":"section"},{"location":"design/","page":"Package design","title":"Package design","text":"To be usable with DifferentiationInterface.jl, an AD backend needs an object subtyping ADTypes.AbstractADType. In addition, some operators must be defined:","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"backend subtype pushforward necessary pullback necessary\nADTypes.ForwardMode yes no\nADTypes.ReverseMode no yes\nADTypes.SymbolicMode yes yes","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"Every backend we support corresponds to a package extension of DifferentiationInterface.jl (located in the ext subfolder). Advanced users are welcome to code more backends and submit pull requests!","category":"page"},{"location":"design/","page":"Package design","title":"Package design","text":"","category":"page"},{"location":"overloads/#Table-of-overloads","page":"Table of overloads","title":"Table of overloads","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"As described in the overview, DifferentiationInterface provides multiple high-level operators like jacobian, each with several variants: ","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"out-of-place or in-place return values\nwith or without primal output value\nsupport for one-argument functions y = f(x) or two-argument functions f!(y, x)","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"To support a new backend, it is only required to define either a pushforward or a pullback function, since DifferentiationInterface provides default implementations of all operators using just these two primitives. However, backends sometimes provide their own implementations of operators, which can be more performant. When available, DifferentiationInterface always calls these backend-specific implementations, which we call \"overloads\".","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"The following tables summarize all implemented overloads for each backend. Each cell can have three values:","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"❌: the operator is not overloaded because the backend does not support it\n✅: the operator is overloaded\nNA: the operator does not exist","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"tip: Tip\nCheck marks (✅) are clickable and link to the source code.","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"using ADTypes: AbstractADType\nusing DifferentiationInterface\nusing DifferentiationInterface: backend_str, mutation_support, MutationSupported\nusing Markdown: Markdown\nusing Diffractor: Diffractor\nusing Enzyme: Enzyme\nusing FastDifferentiation: FastDifferentiation\nusing FiniteDiff: FiniteDiff\nusing FiniteDifferences: FiniteDifferences\nusing ForwardDiff: ForwardDiff\nusing PolyesterForwardDiff: PolyesterForwardDiff\nusing ReverseDiff: ReverseDiff\nusing Tapir: Tapir\nusing Tracker: Tracker\nusing Zygote: Zygote\n\nfunction operators_and_types_f(backend::T) where {T<:AbstractADType}\n    return (\n        # (op,          types_op), \n        # (op!,         types_op!), \n        # (val_and_op,  types_val_and_op),\n        # (val_and_op!, types_val_and_op!),\n        (\n            (:derivative, (Any, T, Any, Any)),\n            (:derivative!, (Any, Any, T, Any, Any)),\n            (:value_and_derivative, (Any, T, Any, Any)),\n            (:value_and_derivative!, (Any, Any, T, Any, Any)),\n        ),\n        (\n            (:gradient, (Any, T, Any, Any)),\n            (:gradient!, (Any, Any, T, Any, Any)),\n            (:value_and_gradient, (Any, T, Any, Any)),\n            (:value_and_gradient!, (Any, Any, T, Any, Any)),\n        ),\n        (\n            (:jacobian, (Any, T, Any, Any)),\n            (:jacobian!, (Any, Any, T, Any, Any)),\n            (:value_and_jacobian, (Any, T, Any, Any)),\n            (:value_and_jacobian!, (Any, Any, T, Any, Any)),\n        ),\n        (\n            (:hessian, (Any, T, Any, Any)),\n            (:hessian!, (Any, Any, T, Any, Any)),\n            (nothing, nothing),\n            (nothing, nothing),\n        ),\n        (\n            (:hvp, (Any, T, Any, Any, Any)),\n            (:hvp!, (Any, Any, T, Any, Any, Any)),\n            (nothing, nothing),\n            (nothing, nothing),\n        ),\n        (\n            (:pullback, (Any, T, Any, Any, Any)),\n            (:pullback!, (Any, Any, T, Any, Any, Any)),\n            (:value_and_pullback, (Any, T, Any, Any, Any)),\n            (:value_and_pullback!, (Any, Any, T, Any, Any, Any)),\n        ),\n        (\n            (:pushforward, (Any, T, Any, Any, Any)),\n            (:pushforward!, (Any, Any, T, Any, Any, Any)),\n            (:value_and_pushforward, (Any, T, Any, Any, Any)),\n            (:value_and_pushforward!, (Any, Any, T, Any, Any, Any)),\n        ),\n    )\nend\nfunction operators_and_types_f!(backend::T) where {T<:AbstractADType}\n    return (\n        (\n            (:derivative, (Any, Any, T, Any, Any)),\n            (:derivative!, (Any, Any, Any, T, Any, Any)),\n            (:value_and_derivative, (Any, Any, T, Any, Any)),\n            (:value_and_derivative!, (Any, Any, Any, T, Any, Any)),\n        ),\n        (\n            (:jacobian, (Any, Any, T, Any, Any)),\n            (:jacobian!, (Any, Any, Any, T, Any, Any)),\n            (:value_and_jacobian, (Any, Any, T, Any, Any)),\n            (:value_and_jacobian!, (Any, Any, Any, T, Any, Any)),\n        ),\n        (\n            (:pullback, (Any, Any, T, Any, Any, Any)),\n            (:pullback!, (Any, Any, Any, T, Any, Any, Any)),\n            (:value_and_pullback, (Any, Any, T, Any, Any, Any)),\n            (:value_and_pullback!, (Any, Any, Any, T, Any, Any, Any)),\n        ),\n        (\n            (:pushforward, (Any, Any, T, Any, Any, Any)),\n            (:pushforward!, (Any, Any, Any, T, Any, Any, Any)),\n            (:value_and_pushforward, (Any, Any, T, Any, Any, Any)),\n            (:value_and_pushforward!, (Any, Any, Any, T, Any, Any, Any)),\n        ),\n    )\nend\n\nfunction method_overloaded(operator::Symbol, argtypes, ext::Module)\n    f = @eval DifferentiationInterface.$operator\n    ms = methods(f, argtypes, ext)\n\n    n = length(ms)\n    n == 0 && return \"❌\"\n    n == 1 && return \"[✅]($(Base.url(only(ms))))\"\n    return \"[✅]($(Base.url(first(ms))))\" # Optional TODO: return all URLs?\nend\n\nfunction print_overload_table(io::IO, operators_and_types, ext::Module)\n    println(io, \"| Operator | `op` | `op!` | `value_and_op` | `value_and_op!` |\")\n    println(io, \"|:---------|:----:|:-----:|:--------------:|:---------------:|\")\n    for operator_variants in operators_and_types\n        opname = first(first(operator_variants))\n        print(io, \"| `$opname` |\")\n        for (op, type_signature) in operator_variants\n            if isnothing(op)\n                print(io, \"NA\")\n            else\n                print(io, method_overloaded(op, type_signature, ext))\n            end\n            print(io, '|')\n        end\n        println(io)\n    end\nend\n\nfunction print_overloads(backend, ext::Symbol)\n    io = IOBuffer()\n    ext = Base.get_extension(DifferentiationInterface, ext)\n\n    println(io, \"#### One-argument functions `y = f(x)`\")\n    println(io)\n    print_overload_table(io, operators_and_types_f(backend), ext)\n\n    println(io, \"#### Two-argument functions `f!(y, x)`\")\n    println(io)\n    if mutation_support(backend) == MutationSupported()\n        print_overload_table(io, operators_and_types_f!(backend), ext)\n    else\n        println(io, \"Backend doesn't support mutating functions.\")\n    end\n\n    return Markdown.parse(String(take!(io)))\nend","category":"page"},{"location":"overloads/#Diffractor-(forward/reverse)","page":"Table of overloads","title":"Diffractor (forward/reverse)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoDiffractor(), :DifferentiationInterfaceDiffractorExt) # hide","category":"page"},{"location":"overloads/#Enzyme-(forward)","page":"Table of overloads","title":"Enzyme (forward)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoEnzyme(; mode=Enzyme.Forward), :DifferentiationInterfaceEnzymeExt) # hide","category":"page"},{"location":"overloads/#Enzyme-(reverse)","page":"Table of overloads","title":"Enzyme (reverse)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoEnzyme(; mode=Enzyme.Reverse), :DifferentiationInterfaceEnzymeExt) # hide","category":"page"},{"location":"overloads/#FastDifferentiation-(symbolic)","page":"Table of overloads","title":"FastDifferentiation (symbolic)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoFastDifferentiation(), :DifferentiationInterfaceFastDifferentiationExt) # hide","category":"page"},{"location":"overloads/#FiniteDiff-(forward)","page":"Table of overloads","title":"FiniteDiff (forward)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoFiniteDiff(), :DifferentiationInterfaceFiniteDiffExt) # hide","category":"page"},{"location":"overloads/#FiniteDifferences-(forward)","page":"Table of overloads","title":"FiniteDifferences (forward)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoFiniteDifferences(; fdm=FiniteDifferences.central_fdm(3, 1)), :DifferentiationInterfaceFiniteDifferencesExt) # hide","category":"page"},{"location":"overloads/#ForwardDiff-(forward)","page":"Table of overloads","title":"ForwardDiff (forward)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoForwardDiff(), :DifferentiationInterfaceForwardDiffExt) # hide","category":"page"},{"location":"overloads/#PolyesterForwardDiff-(forward)","page":"Table of overloads","title":"PolyesterForwardDiff (forward)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoPolyesterForwardDiff(; chunksize=1), :DifferentiationInterfacePolyesterForwardDiffExt) # hide","category":"page"},{"location":"overloads/#ReverseDiff-(reverse)","page":"Table of overloads","title":"ReverseDiff (reverse)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoReverseDiff(), :DifferentiationInterfaceReverseDiffExt) # hide","category":"page"},{"location":"overloads/#Tapir-(reverse)","page":"Table of overloads","title":"Tapir (reverse)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoTapir(), :DifferentiationInterfaceTapirExt) # hide","category":"page"},{"location":"overloads/#Tracker-(reverse)","page":"Table of overloads","title":"Tracker (reverse)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoTracker(), :DifferentiationInterfaceTrackerExt) # hide","category":"page"},{"location":"overloads/#Zygote-(reverse)","page":"Table of overloads","title":"Zygote (reverse)","text":"","category":"section"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"print_overloads(AutoZygote(), :DifferentiationInterfaceZygoteExt) # hide","category":"page"},{"location":"overloads/","page":"Table of overloads","title":"Table of overloads","text":"","category":"page"},{"location":"overview/#sec-overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Operators","page":"Overview","title":"Operators","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Depending on the type of input and output, differentiation operators can have various names.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We provide the following high-level operators:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"operator order input  x output   y result type result shape\nderivative 1 Number Number or AbstractArray same as y size(y)\nsecond_derivative 2 Number Number or AbstractArray same as y size(y)\ngradient 1 AbstractArray Number same as x size(x)\nhvp 2 AbstractArray Number same as x size(x)\nhessian 2 AbstractArray Number AbstractMatrix (length(x), length(x))\njacobian 1 AbstractArray AbstractArray AbstractMatrix (length(y), length(x))","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"They can all be derived from two low-level operators:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"operator order input  x output   y result type result shape\npushforward (or JVP) 1 Any Any same as y size(y)\npullback (or VJP) 1 Any Any same as x size(x)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Luckily, most backends have custom implementations, which we reuse if possible instead of relying on fallbacks.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"tip: Tip\nSee the book The Elements of Differentiable Programming for details on these concepts.","category":"page"},{"location":"overview/#Variants","page":"Overview","title":"Variants","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Several variants of each operator are defined:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"out-of-place in-place out-of-place + primal in-place + primal\nderivative derivative! value_and_derivative value_and_derivative!\nsecond_derivative second_derivative! NA NA\ngradient gradient! value_and_gradient value_and_gradient!\nhvp hvp! NA NA\nhessian hessian! NA NA\njacobian jacobian! value_and_jacobian value_and_jacobian!\npushforward pushforward! value_and_pushforward value_and_pushforward!\npullback pullback! value_and_pullback value_and_pullback!","category":"page"},{"location":"overview/#Mutation-and-signatures","page":"Overview","title":"Mutation and signatures","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In order to ensure symmetry between one-argument functions f(x) = y and two-argument functions f!(y, x) = nothing, we define the same operators for both cases. However they have different signatures:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"signature out-of-place in-place\nf(x) operator(f,     backend, x, ...) operator!(f,     result, backend, x, ...)\nf!(y, x) operator(f!, y, backend, x, ...) operator!(f!, y, result, backend, x, ...)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Warning\nOur mutation convention is that all positional arguments between f/f! and backend are mutated (the extras as well, see below). This convention holds regardless of the bang ! in the operator name, because we assume that a user passing a two-argument function f!(y, x) anticipates mutation anyway.Still, better be careful with two-argument functions, because every variant of the operator will mutate y... even if it does not have a ! in its name (see the bottom left cell in the table).","category":"page"},{"location":"overview/#Preparation","page":"Overview","title":"Preparation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In many cases, AD can be accelerated if the function has been run at least once (e.g. to create a config or record a tape) and if some cache objects are provided. This is a backend-specific procedure, but we expose a common syntax to achieve it.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"operator preparation function\nderivative prepare_derivative\ngradient prepare_gradient\njacobian prepare_jacobian\nsecond_derivative prepare_second_derivative\nhessian prepare_hessian\npushforward prepare_pushforward\npullback prepare_pullback\nhvp prepare_hvp","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Unsurprisingly, preparation syntax depends on the number of arguments:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"signature preparation signature\nf(x) prepare_operator(f,     backend, x, ...)\nf!(y, x) prepare_operator(f!, y, backend, x, ...)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The preparation prepare_operator(f, backend, x) will create an object called extras containing the necessary information to speed up operator and its variants. This information is specific to backend and f, as well as the type and size of the input x and the control flow within the function, but it should work with different values of x.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"You can then call e.g. operator(backend, f, x2, extras), which should be faster than operator(f, backend, x2). This is especially worth it if you plan to call operator several times in similar settings: you can think of it as a warm up.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThe extras object is nearly always mutated when given to an operator, even when said operator does not have a bang ! in its name.","category":"page"},{"location":"overview/#Second-order","page":"Overview","title":"Second order","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We offer two ways to perform second-order differentiation (for second_derivative, hvp and hessian):","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"pick a single backend to do all the work\ncombine an \"outer\" and \"inner\" backend within the SecondOrder struct: the inner backend will be called first, and the outer backend will differentiate the generated code","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"warning: Warning\nThere are many possible backend combinations, a lot of which will fail. At the moment, trial and error is your best friend. Usually, the most efficient approach for Hessians is forward-over-reverse, i.e. a forward-mode outer backend and a reverse-mode inner backend.","category":"page"},{"location":"overview/#Experimental","page":"Overview","title":"Experimental","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"danger: Danger\nEverything in this section is still experimental, use it at your own risk.","category":"page"},{"location":"overview/#Sparsity","page":"Overview","title":"Sparsity","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"ADTypes.jl provides AutoSparse to accelerate the computation of sparse Jacobians and Hessians:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"for sparse Jacobians, wrap AutoSparse around a first-order backend.\nfor sparse Hessians, wrap AutoSparse around a SecondOrder backend.","category":"page"},{"location":"overview/#Split-reverse-mode","page":"Overview","title":"Split reverse mode","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Some reverse mode AD backends expose a \"split\" option, which runs only the forward sweep, and encapsulates the reverse sweep in a closure. We make this available for all backends with the following operators:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"out-of-place in-place\nvalue_and_pullback_split value_and_pullback!_split","category":"page"},{"location":"overview/#Translation","page":"Overview","title":"Translation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The wrapper DifferentiateWith allows you to take a function and specify that it should be differentiated with the backend of your choice. In other words, when you try to differentiate dw = DifferentiateWith(f, backend1) with backend2, then backend1 steps in and backend2 does nothing. At the moment it only works when backend2 supports ChainRules.jl.","category":"page"},{"location":"overview/#Going-further","page":"Overview","title":"Going further","text":"","category":"section"},{"location":"overview/#Non-standard-types","page":"Overview","title":"Non-standard types","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The package is thoroughly tested with inputs and outputs of the following types: Float64, Vector{Float64} and Matrix{Float64}. We also expect it to work on most kinds of Number and AbstractArray variables. Beyond that, you are in uncharted territory. We voluntarily keep the type annotations minimal, so that passing more complex objects or custom structs might work with some backends, but we make no guarantees about that.","category":"page"},{"location":"overview/#Multiple-inputs/outputs","page":"Overview","title":"Multiple inputs/outputs","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Restricting the API to one input and one output has many coding advantages, but it is not very flexible. If you need more than that, use ComponentArrays.jl to wrap several objects inside a single ComponentVector.","category":"page"},{"location":"overview/#Batched-evaluation","page":"Overview","title":"Batched evaluation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"This is not supported at the moment, but we plan to allow several pushforward / pullback seeds at once (similar to the chunking in ForwardDiff.jl or the batches in Enzyme.jl).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"using DifferentiationInterface\nusing DifferentiationInterface: backend_str\nimport Markdown\nimport Diffractor, Enzyme, FastDifferentiation, FiniteDiff, FiniteDifferences, ForwardDiff, PolyesterForwardDiff, ReverseDiff, Tapir, Tracker, Zygote\n\nconst backend_examples = (\n    \"AutoDiffractor()\",\n    \"AutoEnzyme(; mode=Enzyme.Forward)\",\n    \"AutoEnzyme(; mode=Enzyme.Reverse)\",\n    \"AutoFastDifferentiation()\",\n    \"AutoFiniteDiff()\",\n    \"AutoFiniteDifferences(; fdm=FiniteDifferences.central_fdm(3, 1))\",\n    \"AutoForwardDiff()\",\n    \"AutoPolyesterForwardDiff(; chunksize=1)\",\n    \"AutoReverseDiff()\",\n    \"AutoTapir()\",\n    \"AutoTracker()\",\n    \"AutoZygote()\",\n)\n\ncheckmark(x::Bool) = x ? '✅' : '❌'\nunicode_check_available(backend) = checkmark(check_available(backend))\nunicode_check_hessian(backend)   = checkmark(check_hessian(backend))\nunicode_check_twoarg(backend)    = checkmark(check_twoarg(backend))\n\nio = IOBuffer()\n\n# Table header \nprintln(io, \"| Backend | Availability | Two-argument functions | Hessian support | Example |\")\nprintln(io, \"|:--------|:------------:|:----------------------:|:---------------:|:--------|\")\n\nfor example in backend_examples\n    b = eval(Meta.parse(example)) # backend\n    join(io, [backend_str(b), unicode_check_available(b), unicode_check_twoarg(b), unicode_check_hessian(b), \"`$example`\"], '|')\n    println(io, '|' )\nend\nbackend_table = Markdown.parse(String(take!(io)))","category":"page"},{"location":"backends/#Backends","page":"Backends","title":"Backends","text":"","category":"section"},{"location":"backends/#Types","page":"Backends","title":"Types","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"We support all dense backend choices from ADTypes.jl, as well as their sparse wrapper AutoSparse.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"For sparse backends, only the Jacobian and Hessian operators are implemented differently, the other operators behave the same as for the corresponding dense backend.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"backend_table #hide","category":"page"},{"location":"backends/#Availability","page":"Backends","title":"Availability","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"You can use check_available to verify whether a given backend is loaded.","category":"page"},{"location":"backends/#Support-for-two-argument-functions","page":"Backends","title":"Support for two-argument functions","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"All backends are compatible with one-argument functions f(x) = y. Only some are compatible with two-argument functions f!(y, x) = nothing. You can check this compatibility using check_twoarg.","category":"page"},{"location":"backends/#Hessian-support","page":"Backends","title":"Hessian support","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"Only some backends are able to compute Hessians. You can use check_hessian to check this feature.","category":"page"},{"location":"backends/#API-reference","page":"Backends","title":"API reference","text":"","category":"section"},{"location":"backends/","page":"Backends","title":"Backends","text":"warning: Warning\nThe following documentation has been re-exported from ADTypes.jl. Refer to the ADTypes documentation for more information.","category":"page"},{"location":"backends/","page":"Backends","title":"Backends","text":"ADTypes\nADTypes.AbstractADType\nAutoChainRules\nAutoDiffractor\nAutoEnzyme\nAutoFastDifferentiation\nAutoFiniteDiff\nAutoFiniteDifferences\nAutoForwardDiff\nAutoPolyesterForwardDiff\nAutoReverseDiff\nAutoSymbolics\nAutoTapir\nAutoTracker\nAutoZygote\nAutoSparse","category":"page"},{"location":"backends/#ADTypes.ADTypes","page":"Backends","title":"ADTypes.ADTypes","text":"ADTypes.jl\n\nADTypes.jl is a multi-valued logic system to choose an automatic differentiation (AD) package and specify its parameters.\n\n\n\n\n\n","category":"module"},{"location":"backends/#ADTypes.AbstractADType","page":"Backends","title":"ADTypes.AbstractADType","text":"AbstractADType\n\nAbstract supertype for all AD choices.\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoChainRules","page":"Backends","title":"ADTypes.AutoChainRules","text":"AutoChainRules{RC}\n\nChooses any AD library based on ChainRulesCore.jl (see the list here).\n\nFields\n\nruleconfig::RC: a ChainRulesCore.RuleConfig object.\n\nConstructor\n\nAutoChainRules(; ruleconfig)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoDiffractor","page":"Backends","title":"ADTypes.AutoDiffractor","text":"AutoDiffractor\n\nChooses Diffractor.jl.\n\nConstructor\n\nAutoDiffractor()\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoEnzyme","page":"Backends","title":"ADTypes.AutoEnzyme","text":"AutoEnzyme{M}\n\nChooses Enzyme.jl.\n\nFields\n\nmode::M: can be either \nan object subtyping EnzymeCore.Mode (like EnzymeCore.Forward or EnzymeCore.Reverse) if a specific mode is required\nnothing to choose the best mode automatically\n\nConstructors\n\nAutoEnzyme(; mode=nothing)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoFastDifferentiation","page":"Backends","title":"ADTypes.AutoFastDifferentiation","text":"AutoFastDifferentiation\n\nChooses FastDifferentiation.jl.\n\nConstructor\n\nAutoFastDifferentiation()\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoFiniteDiff","page":"Backends","title":"ADTypes.AutoFiniteDiff","text":"AutoFiniteDiff{T1,T2,T3}\n\nChooses FiniteDiff.jl.\n\nFields\n\nfdtype::T1: finite difference type\nfdjtype::T2: finite difference type for the Jacobian\nfdhtype::T3: finite difference type for the Hessian\n\nConstructor\n\nAutoFiniteDiff(; fdtype=Val(:forward), fdjtype=fdtype, fdhtype=Val(:hcentral))\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoFiniteDifferences","page":"Backends","title":"ADTypes.AutoFiniteDifferences","text":"AutoFiniteDifferences{T}\n\nChooses FiniteDifferences.jl.\n\nFields\n\nfdm::T: a FiniteDifferenceMethod\n\nConstructor\n\nAutoFiniteDifferences(; fdm)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoForwardDiff","page":"Backends","title":"ADTypes.AutoForwardDiff","text":"AutoForwardDiff{chunksize,T}\n\nChooses ForwardDiff.jl.\n\nType parameters\n\nchunksize: the preferred chunk size to evaluate several derivatives at once\n\nFields\n\ntag::T: a custom tag to handle nested differentiation calls (usually not necessary)\n\nConstructors\n\nAutoForwardDiff(; chunksize=nothing, tag=nothing)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoPolyesterForwardDiff","page":"Backends","title":"ADTypes.AutoPolyesterForwardDiff","text":"AutoPolyesterForwardDiff{chunksize,T}\n\nChooses PolyesterForwardDiff.jl.\n\nType parameters\n\nchunksize: the preferred chunk size to evaluate several derivatives at once\n\nFields\n\ntag::T: a custom tag to handle nested differentiation calls (usually not necessary)\n\nConstructors\n\nAutoPolyesterForwardDiff(; chunksize=nothing, tag=nothing)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoReverseDiff","page":"Backends","title":"ADTypes.AutoReverseDiff","text":"AutoReverseDiff\n\nChooses ReverseDiff.jl.\n\nFields\n\ncompile::Bool: whether to compile the tape prior to differentiation\n\nConstructor\n\nAutoReverseDiff(; compile=false)\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSymbolics","page":"Backends","title":"ADTypes.AutoSymbolics","text":"AutoSymbolics\n\nChooses Symbolics.jl.\n\nConstructor\n\nAutoSymbolics()\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoTapir","page":"Backends","title":"ADTypes.AutoTapir","text":"AutoTapir\n\nChooses Tapir.jl.\n\nConstructor\n\nAutoTapir()\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoTracker","page":"Backends","title":"ADTypes.AutoTracker","text":"AutoTracker\n\nChooses Tracker.jl.\n\nConstructor\n\nAutoTracker()\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoZygote","page":"Backends","title":"ADTypes.AutoZygote","text":"AutoZygote\n\nChooses Zygote.jl.\n\nConstructor\n\nAutoZygote()\n\n\n\n\n\n","category":"type"},{"location":"backends/#ADTypes.AutoSparse","page":"Backends","title":"ADTypes.AutoSparse","text":"AutoSparse{D,S,C}\n\nWraps an ADTypes.jl object to deal with sparse Jacobians and Hessians.\n\nFields\n\ndense_ad::D: the underlying AD package, subtyping AbstractADType\nsparsity_detector::S: the sparsity pattern detector, subtyping AbstractSparsityDetector\ncoloring_algorithm::C: the coloring algorithm, subtyping AbstractColoringAlgorithm\n\nConstructors\n\nAutoSparse(\n    dense_ad;\n    sparsity_detector=ADTypes.NoSparsityDetector(),\n    coloring_algorithm=ADTypes.NoColoringAlgorithm()\n)\n\n\n\n\n\n","category":"type"},{"location":"backends/","page":"Backends","title":"Backends","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: DifferentiationInterface Logo)","category":"page"},{"location":"#DifferentiationInterface","page":"Home","title":"DifferentiationInterface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Package Docs\nDifferentiationInterface (Image: Stable)     (Image: Dev)\nDifferentiationInterfaceTest (Image: Stable) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An interface to various automatic differentiation (AD) backends in Julia.","category":"page"},{"location":"#Goal","page":"Home","title":"Goal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a backend-agnostic syntax to differentiate functions of the following types:","category":"page"},{"location":"","page":"Home","title":"Home","text":"one-argument functions (allocating): f(x) = y\ntwo-argument functions (mutating): f!(y, x) = nothing","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First- and second-order operators (gradients, Jacobians, Hessians and more)\nIn-place and out-of-place differentiation\nPreparation mechanism (e.g. to create a config or tape)\nThorough validation on standard inputs and outputs (numbers, vectors, matrices)\nTesting and benchmarking utilities accessible to users with DifferentiationInterfaceTest","category":"page"},{"location":"#Compatibility","page":"Home","title":"Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We support all of the backends defined by ADTypes.jl v1.0:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChainRulesCore.jl\nDiffractor.jl\nEnzyme.jl\nFastDifferentiation.jl\nFiniteDiff.jl\nFiniteDifferences.jl\nForwardDiff.jl\nPolyesterForwardDiff.jl\nReverseDiff.jl\nSparseDiffTools.jl\nSymbolics.jl\nTapir.jl\nTracker.jl\nZygote.jl","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the stable version of the package, run the following code in a Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"DifferentiationInterface\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the development version, run this instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\n        url=\"https://github.com/gdalle/DifferentiationInterface.jl\",\n        subdir=\"DifferentiationInterface\"\n    )","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DifferentiationInterface\nimport ForwardDiff, Enzyme, Zygote          # import automatic differentiation backends you want to use \n\nf(x) = sum(abs2, x)\n\nx = [1.0, 2.0, 3.0]\n\nvalue_and_gradient(f, AutoForwardDiff(), x) # returns (14.0, [2.0, 4.0, 6.0]) using ForwardDiff.jl\nvalue_and_gradient(f, AutoEnzyme(),      x) # returns (14.0, [2.0, 4.0, 6.0]) using Enzyme.jl\nvalue_and_gradient(f, AutoZygote(),      x) # returns (14.0, [2.0, 4.0, 6.0]) using Zygote.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more performance, take a look at the DifferentiationInterface tutorial.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AbstractDifferentiation.jl is the original inspiration for DifferentiationInterface.jl.\nAutoDiffOperators.jl is an attempt to bridge ADTypes.jl with AbstractDifferentiation.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"extensions/#Package-extensions","page":"Package extensions","title":"Package extensions","text":"","category":"section"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"CurrentModule = DifferentiationInterface","category":"page"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"Package extension content is not part of the public API. If any docstrings are present in an extension, they will appear below.","category":"page"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"Modules = [\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceChainRulesCoreExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceDiffractorExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceEnzymeExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFastDifferentiationExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFiniteDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFiniteDifferencesExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceForwardDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfacePolyesterForwardDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceReverseDiffExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceSymbolicsExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceTapirExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceTrackerExt),\n    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceZygoteExt)\n]\nFilter = t -> !(t isa Type && t <: ADTypes.AbstractADType)","category":"page"},{"location":"extensions/","page":"Package extensions","title":"Package extensions","text":"","category":"page"}]
}
