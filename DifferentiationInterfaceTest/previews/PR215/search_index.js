var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"DifferentiationInterfaceTest","category":"page"},{"location":"api/#DifferentiationInterfaceTest","page":"API reference","title":"DifferentiationInterfaceTest","text":"DifferentiationInterfaceTest\n\nTesting and benchmarking utilities for automatic differentiation in Julia.\n\nExports\n\nAbstractScenario\nDerivativeScenario\nGradientScenario\nHVPScenario\nHessianScenario\nJacobianScenario\nPullbackScenario\nPushforwardScenario\nSecondDerivativeScenario\nbenchmark_differentiation\ncomponent_scenarios\ndefault_scenarios\ngpu_scenarios\nsparse_scenarios\nstatic_scenarios\ntest_differentiation\n\n\n\n\n\n","category":"module"},{"location":"api/#Entry-points","page":"API reference","title":"Entry points","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"test_differentiation\nbenchmark_differentiation","category":"page"},{"location":"api/#DifferentiationInterfaceTest.test_differentiation","page":"API reference","title":"DifferentiationInterfaceTest.test_differentiation","text":"test_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType};\n    ...\n)\ntest_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType},\n    scenarios::Vector{<:AbstractScenario};\n    correctness,\n    type_stability,\n    call_count,\n    sparsity,\n    ref_backend,\n    detailed,\n    input_type,\n    output_type,\n    first_order,\n    second_order,\n    excluded,\n    logging,\n    isapprox,\n    atol,\n    rtol\n)\n\n\nCross-test a list of backends on a list of scenarios, running a variety of different tests.\n\nDefault arguments\n\nscenarios::Vector{<:AbstractScenario}: the output of default_scenarios()\n\nKeyword arguments\n\nTesting:\n\ncorrectness=true: whether to compare the differentiation results with the theoretical values specified in each scenario\ntype_stability=false: whether to check type stability with JET.jl (thanks to @test_opt)\nsparsity: whether to check sparsity of the jacobian / hessian\nref_backend: if not nothing, an ADTypes.AbstractADType object to use instead of the scenario-specific reference to provide true values\ndetailed=false: whether to print a detailed or condensed test log\n\nFiltering:\n\ninput_type=Any: restrict scenario inputs to subtypes of this\noutput_type=Any: restrict scenario outputs to subtypes of this\nfirst_order=true: include first order operators\nsecond_order=true: include second order operators\n\nOptions:\n\nlogging=false: whether to log progress\nisapprox=isapprox: function used to compare objects, with the standard signature isapprox(x, y; atol, rtol)\natol=0: absolute precision for correctness testing (when comparing to the reference outputs)\nrtol=1e-3: relative precision for correctness testing (when comparing to the reference outputs)\n\n\n\n\n\ntest_differentiation(\n    backend::ADTypes.AbstractADType,\n    args...;\n    kwargs...\n)\n\n\nShortcut for a single backend.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.benchmark_differentiation","page":"API reference","title":"DifferentiationInterfaceTest.benchmark_differentiation","text":"benchmark_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType};\n    ...\n) -> Vector{DifferentiationInterfaceTest.BenchmarkDataRow}\nbenchmark_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType},\n    scenarios::Vector{<:AbstractScenario};\n    input_type,\n    output_type,\n    first_order,\n    second_order,\n    excluded,\n    logging\n) -> Vector{DifferentiationInterfaceTest.BenchmarkDataRow}\n\n\nBenchmark a list of backends for a list of operators on a list of scenarios.\n\nKeyword arguments\n\nfiltering: same as test_differentiation for the filtering part.\nlogging=false: whether to log progress\n\n\n\n\n\n","category":"function"},{"location":"api/#Pre-made-scenario-lists","page":"API reference","title":"Pre-made scenario lists","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"default_scenarios\nsparse_scenarios\ncomponent_scenarios\ngpu_scenarios\nstatic_scenarios","category":"page"},{"location":"api/#DifferentiationInterfaceTest.default_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.default_scenarios","text":"default_scenarios()\n\nCreate a vector of AbstractScenarios with standard array types.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.sparse_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.sparse_scenarios","text":"sparse_scenarios()\n\nCreate a vector of AbstractScenarios with sparse array types, focused on sparse Jacobians and Hessians.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.component_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.component_scenarios","text":"component_scenarios()\n\nCreate a vector of AbstractScenarios with component array types from ComponentArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.gpu_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.gpu_scenarios","text":"gpu_scenarios()\n\nCreate a vector of AbstractScenarios with GPU array types from JLArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.static_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.static_scenarios","text":"static_scenarios()\n\nCreate a vector of AbstractScenarios with static array types from StaticArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Scenario-types","page":"API reference","title":"Scenario types","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"AbstractScenario\nPushforwardScenario\nPullbackScenario\nDerivativeScenario\nGradientScenario\nJacobianScenario\nSecondDerivativeScenario\nHVPScenario\nHessianScenario","category":"page"},{"location":"api/#DifferentiationInterfaceTest.AbstractScenario","page":"API reference","title":"DifferentiationInterfaceTest.AbstractScenario","text":"AbstractScenario\n\nStore a testing scenario composed of a function and its input + output.\n\nThis abstract type should never be used directly: construct one of the subtypes corresponding to the operator you want to test.\n\nSubtypes\n\nPushforwardScenario\nPullbackScenario\nDerivativeScenario\nGradientScenario\nJacobianScenario\nSecondDerivativeScenario\nHVPScenario\nHessianScenario\n\nFields\n\nAll subtypes have the following fields:\n\nf: function to apply\nx: primal input\ny: primal output\nref: reference to compare against\n\nIn addition, some subtypes contain an additional seed (dx or dy).\n\nConstructor\n\nIf y is provided, f is interpreted as a 2-argument function f!(y, x) = nothing. Otherwise, f is interpreted as an 1-argument function f(x) = y.\n\nThe reference keyword ref should be a function that takes x (and a potential seed dx or dy) to return the correct object.\n\nThe operator behavior keyword operator should be either :inplace or :outofplace depending on what must be tested.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.PushforwardScenario","page":"API reference","title":"DifferentiationInterfaceTest.PushforwardScenario","text":"PushforwardScenario(f; x, y, dx, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.PullbackScenario","page":"API reference","title":"DifferentiationInterfaceTest.PullbackScenario","text":"PullbackScenario(f; x, y, dy, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.DerivativeScenario","page":"API reference","title":"DifferentiationInterfaceTest.DerivativeScenario","text":"DerivativeScenario(f; x, y, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.GradientScenario","page":"API reference","title":"DifferentiationInterfaceTest.GradientScenario","text":"GradientScenario(f; x, y, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.JacobianScenario","page":"API reference","title":"DifferentiationInterfaceTest.JacobianScenario","text":"JacobianScenario(f; x, y, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.SecondDerivativeScenario","page":"API reference","title":"DifferentiationInterfaceTest.SecondDerivativeScenario","text":"SecondDerivativeScenario(f; x, y, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.HVPScenario","page":"API reference","title":"DifferentiationInterfaceTest.HVPScenario","text":"HVPScenario(f; x, y, dx, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.HessianScenario","page":"API reference","title":"DifferentiationInterfaceTest.HessianScenario","text":"HessianScenario(f; x, y, ref, operator)\n\nSee AbstractScenario for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This is not part of the public API.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DifferentiationInterfaceTest]\nPublic = false","category":"page"},{"location":"api/#DifferentiationInterfaceTest.AutoZeroForward","page":"API reference","title":"DifferentiationInterfaceTest.AutoZeroForward","text":"AutoZeroForward <: ADTypes.AbstractADType\n\nTrivial backend that sets all derivatives to zero. Used in testing and benchmarking.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.AutoZeroReverse","page":"API reference","title":"DifferentiationInterfaceTest.AutoZeroReverse","text":"AutoZeroReverse <: ADTypes.AbstractADType\n\nTrivial backend that sets all derivatives to zero. Used in testing and benchmarking.\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.BenchmarkDataRow","page":"API reference","title":"DifferentiationInterfaceTest.BenchmarkDataRow","text":"BenchmarkDataRow\n\nAd-hoc storage type for differentiation benchmarking results. If you have a vector rows::Vector{BenchmarkDataRow}, you can turn it into a DataFrame as follows:\n\ndf = DataFrames.DataFrame(rows)\n\nFields\n\nThese are not part of the public API.\n\nbackend::String\nmode::ADTypes.AbstractMode\nscenario::Symbol\noperator::Symbol\nfunc::Symbol\narguments::Int64\ninput_type::Type\noutput_type::Type\ninput_size::Tuple\noutput_size::Tuple\ncalls::Int64\nsamples::Int64\nevals::Int64\ntime::Float64\nbytes::Float64\nallocs::Float64\ncompile_fraction::Float64\ngc_fraction::Float64\n\n\n\n\n\n","category":"type"},{"location":"#DifferentiationInterfaceTest","page":"Home","title":"DifferentiationInterfaceTest","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Package Docs\nDifferentiationInterface (Image: Stable)     (Image: Dev)\nDifferentiationInterfaceTest (Image: Stable) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Testing and benchmarking utilities for automatic differentiation (AD) in Julia, based on DifferentiationInterface.","category":"page"},{"location":"#Goal","page":"Home","title":"Goal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Make it easy to know, for a given function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"which AD backends can differentiate it\nhow fast they can do it","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Predefined or custom test scenarios\nCorrectness tests\nType stability tests\nCount calls to the function\nBenchmark runtime and allocations\nWeird array types (GPU, static, components)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the stable version of the package, run the following code in a Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"DifferentiationInterfaceTest\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the development version, run this instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\n        url=\"https://github.com/gdalle/DifferentiationInterface.jl\",\n        subdir=\"DifferentiationInterface\"\n    )\n    \njulia> Pkg.add(\n        url=\"https://github.com/gdalle/DifferentiationInterface.jl\",\n        subdir=\"DifferentiationInterfaceTest\"\n    )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Main","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We present a typical workflow with DifferentiationInterfaceTest.jl, building on the DifferentiationInterface.jl tutorial (which we encourage you to read first).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentiationInterface, DifferentiationInterfaceTest\nimport ADTypes, ForwardDiff, Enzyme\nimport DataFrames, Markdown, PrettyTables, Printf","category":"page"},{"location":"tutorial/#Introduction","page":"Tutorial","title":"Introduction","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The AD backends we want to compare are ForwardDiff.jl and Enzyme.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backends = [ADTypes.AutoForwardDiff(), ADTypes.AutoEnzyme(; mode=Enzyme.Reverse)]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To do that, we are going to take gradients of a simple function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x::AbstractArray) = sum(sin, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Of course we know the true gradient mapping:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"∇f(x::AbstractArray) = cos.(x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DifferentiationInterfaceTest.jl relies with so-called \"scenarios\", in which you encapsulate the information needed for your test:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the function f\nthe input x (and output y for mutating functions)\noptionally a reference ref to check against","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There is one scenario per operator, and so here we will use GradientScenario:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"scenarios = [\n    GradientScenario(f; x=rand(Float32, 3), ref=∇f, operator=:inplace),\n    GradientScenario(f; x=rand(Float64, 3, 2), ref=∇f, operator=:inplace)\n];","category":"page"},{"location":"tutorial/#Testing","page":"Tutorial","title":"Testing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main entry point for testing is the function test_differentiation. It has many options, but the main ingredients are the following:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"test_differentiation(\n    backends,  # the backends you want to compare\n    scenarios,  # the scenarios you defined,\n    correctness=true,  # compares values against the reference\n    type_stability=false,  # checks type stability with JET.jl\n    detailed=true,  # prints a detailed test set\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you are too lazy to manually specify the reference, you can also provide an AD backend as the ref_backend keyword argument, which will serve as the ground truth for comparison.","category":"page"},{"location":"tutorial/#Benchmarking","page":"Tutorial","title":"Benchmarking","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once you are confident that your backends give the correct answers, you probably want to compare their performance. This is made easy by the benchmark_differentiation function, whose syntax should feel familiar:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"benchmark_result = benchmark_differentiation(backends, scenarios);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting object is a Vector of structs, which can easily be converted into a DataFrame from DataFrames.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = DataFrames.DataFrame(benchmark_result)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here's what the resulting DataFrame looks like with all its columns. Note that we only compare (possibly) in-place operators, because they are always more efficient.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function formatter(v, i, j)\n    if j in (14, 15)  # time, bytes\n        return Printf.@sprintf(\"%.1e\", v)\n    elseif j == 16  # allocs\n        return Printf.@sprintf(\"%.1f\", v)\n    else\n        return v\n    end\nend\n\ntable = PrettyTables.pretty_table(\n    String,\n    df;\n    backend=Val(:markdown),\n    header=names(df),\n    formatters=formatter\n)\n\nMarkdown.parse(table)","category":"page"}]
}
